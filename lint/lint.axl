"""Define the 'lint' task

First, perform a build with linting aspects enabled, and selecting appropriate output groups.
These can be remotely cached like any other actions.

Then collect the results for presentation, either locally on the terminal or in the code review with Aspect's Marvin bot.

Install:
    Add rules_lint to MODULE.aspect.
    See examples in https://github.com/bazel-starters

Usage:
    # Lint all targets in the repository
    aspect lint
    # Lint specific targets
    aspect lint -- //path/to:targets -//not:this_one
    # Fix lint violations, where the underlying linter provides fixes
    aspect lint --fix
"""

# buildifier: disable=function-docstring
def impl(ctx: TaskContext) -> int:
    flags = [
        "--config=lint",
        "--remote_download_regex='.*AspectRulesLint.*'",
    ]
    if ctx.args.fix:
        flags.append("--output_groups=rules_lint_patch")
        flags.append("--@aspect_rules_lint//lint:fix")
    # Note: to test the non-interactive codepath, run with:
    # echo > nohup.out; nohup aspect lint ; cat nohup.out
    flags.append("--output_groups=rules_lint_" + (
        "human" if ctx.std.io.stdout.is_tty else "machine"))
    build = ctx.bazel.build(
        flags = flags,
        build_events = True,
        *(ctx.args.targets or ["//..."])
    )
    github_output = ctx.std.env.var("GITHUB_OUTPUT")
    exit_code = 0
    patches = []
    for event in build.build_events():
        if event.kind == "named_set_of_files":
            for file in event.payload.files:
                filepath = file.file.removeprefix("file://")
                if file.name.endswith(".out"):
                    generated = ctx.std.fs.read_to_string(filepath)
                    ctx.std.io.stderr.write(generated)
                if file.name.endswith(".report"):
                    report = ctx.std.fs.read_to_string(filepath)
                    ctx.std.io.stdout.write(report)
                    if github_output:
                        ctx.std.fs.write(github_output, "lint-report=" + filepath)
                if file.name.endswith(".patch"):
                    patches.append(file.file.removeprefix("file://"))
                if file.name.endswith(".exit_code"):
                    if int(ctx.std.fs.read_to_string(filepath).rstrip()) != 0:
                        exit_code = 1
    if not build.wait().success:
        exit_code = 1
    if ctx.args.fix:
        for patch in patches:
            ctx.std.process.command("patch").arg("-p1").arg("--input=" + patch).current_dir(ctx.std.env.current_dir()).spawn().wait()

    return exit_code

lint = task(
    implementation = impl,
    args = {
        "fix": args.boolean(),
        "targets": args.positional(minimum = 0),
    },
)

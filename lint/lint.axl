"""Define the 'lint' task

First, perform a build with linting aspects enabled, and selecting appropriate output groups.
These can be remotely cached like any other actions.

Then collect the results for presentation, either locally on the terminal or in the code review with Aspect's Marvin bot.

Install:
    Add rules_lint to MODULE.aspect.
    See examples in https://github.com/bazel-starters

Usage:
    # Lint all targets in the repository
    aspect lint
    # Lint specific targets
    aspect lint -- //path/to:targets -//not:this_one
    # Fix lint violations, where the underlying linter provides fixes
    aspect lint --fix
"""

load("./sarif.axl", "parse_sarif", "parse_sarif_diagnostics", "get_sarif_summary")

def parse_diff_output(output):
    """
    Parse raw `git diff --unified=0` output into changed file/line information.

    Args:
        output: Raw output string from `git diff --unified=0`

    Returns:
        List of dicts: [{"file": str, "lines": [int]}]
        lines are 0-based line numbers of added lines only.
        Deleted files are excluded.
    """
    files = []
    current_file = None

    for line in output.split("\n"):
        if line.startswith("+++ b/"):
            path = line.removeprefix("+++ b/")
            current_file = {"file": path, "lines": []}
            files.append(current_file)
        elif line.startswith("--- /dev/null"):
            # Next +++ line is a new file (not a deletion); handled naturally
            pass
        elif line.startswith("+++ /dev/null"):
            # File was deleted — remove the entry we just added
            if current_file:
                files.pop()
                current_file = None
        elif line.startswith("@@ ") and current_file != None:
            # Parse hunk header: @@ -old,count +new,count @@
            # We only care about the +new,count part
            parts = line.split(" ")
            for part in parts:
                if part.startswith("+") and part != "+++":
                    # +start or +start,count
                    plus = part.removeprefix("+")
                    if "," in plus:
                        chunks = plus.split(",")
                        start = int(chunks[0])
                        count = int(chunks[1])
                    else:
                        start = int(plus)
                        count = 1
                    if count > 0:
                        # Convert to 0-based line numbers
                        for i in range(count):
                            current_file["lines"].append(start - 1 + i)
                    break

    return files


# ChangedFilesProvider
ChangedFilesProvider = record(
    get_changed_files = field(typing.Callable[[TaskContext, dict], list]),
    # Returns: [{"file": "path/to/file.py", "lines": [0, 4, 9]}, ...]
    # lines = 0-based line numbers of added lines only
    # Empty list = no change context available
)


def _git_diff_get_changed_files(ctx, state):
    result = ctx.std.process.command("git") \
        .args(["diff", "HEAD~1", "--unified=0"]) \
        .current_dir(ctx.std.env.current_dir()) \
        .stdout("piped").stderr("piped").spawn().wait_with_output()
    if not result.status.success:
        return []  # no previous commit or not a git repo
    return parse_diff_output(result.stdout)

GitDiffProvider = ChangedFilesProvider(
    get_changed_files = _git_diff_get_changed_files,
)

Strategy = record(
    needs_machine = field(bool, False),
    setup = field(typing.Callable[[TaskContext, dict], None]),
    process = field(typing.Callable[[TaskContext, dict, str], None]),  # str = SARIF filepath
    finish = field(typing.Callable[[TaskContext, dict], int]),         # returns exit code
)


# Built-in strategies
def _soft_setup(ctx, state):
    state["diagnostics"] = []

def _soft_process(ctx, state, filepath):
    content = ctx.std.fs.read_to_string(filepath)
    state["diagnostics"].extend(parse_sarif_diagnostics(content))

def _soft_finish(ctx, state):
    return 0

StrategySoft = Strategy(
    needs_machine = True,
    setup = _soft_setup,
    process = _soft_process,
    finish = _soft_finish,
)


def _hard_setup(ctx, state):
    state["diagnostics"] = []

def _hard_process(ctx, state, filepath):
    content = ctx.std.fs.read_to_string(filepath)
    state["diagnostics"].extend(parse_sarif_diagnostics(content))

def _hard_finish(ctx, state):
    for diag in state["diagnostics"]:
        if diag["severity"] == "error":
            return 1
    if state.get("raw_exit_code", 0) != 0:
        return 1
    return 0

StrategyHard = Strategy(
    needs_machine = True,
    setup = _hard_setup,
    process = _hard_process,
    finish = _hard_finish,
)


def _hold_the_line_setup(ctx, state):
    state["diagnostics"] = []
    state["changed_files"] = ctx.config.changed_files_provider.get_changed_files(ctx, state)

def _hold_the_line_process(ctx, state, filepath):
    content = ctx.std.fs.read_to_string(filepath)
    state["diagnostics"].extend(parse_sarif_diagnostics(content))

def _hold_the_line_finish(ctx, state):
    changed_files = state.get("changed_files", [])
    if not changed_files:
        return 0  # no change context available

    changed_paths = {}
    for cf in changed_files:
        changed_paths[cf["file"]] = True

    for diag in state["diagnostics"]:
        if diag["severity"] == "error" and diag["file"] in changed_paths:
            return 1

    return 0

StrategyHoldTheLine = Strategy(
    needs_machine = True,
    setup = _hold_the_line_setup,
    process = _hold_the_line_process,
    finish = _hold_the_line_finish,
)


LintConfig = spec(
    strategy = attr(Strategy, StrategyHoldTheLine),
    changed_files_provider = attr(ChangedFilesProvider, GitDiffProvider),
)

# buildifier: disable=function-docstring
def impl(ctx: TaskContext) -> int:
    state = {}
    strategy = ctx.config.strategy

    # 1. Setup
    strategy.setup(ctx, state)

    # 2. Build flags
    flags = [
        "--config=lint",
        "--remote_download_regex='.*AspectRulesLint.*'",
    ]
    if ctx.args.fix:
        flags.append("--output_groups=rules_lint_patch")
        flags.append("--@aspect_rules_lint//lint:fix")
    # Note: to test the non-interactive codepath, run with:
    # echo > nohup.out; nohup aspect lint ; cat nohup.out
    flags.append("--output_groups=rules_lint_" + (
        "human" if ctx.std.io.stdout.is_tty else "machine"))
    if strategy.needs_machine:
        flags.append("--output_groups=rules_lint_machine")

    # 3. Build
    build = ctx.bazel.build(
        flags = flags,
        build_events = True,
        *(ctx.args.targets or ["//..."])
    )
    github_output = ctx.std.env.var("GITHUB_OUTPUT")
    exit_code = 0
    patches = []
    for event in build.build_events():
        if not ctx.args.quiet and event.kind == "workspace_status":
            print("Running workspace_status command...")
        elif not ctx.args.quiet and event.kind == "target_completed":
            message = "Target: " + event.id.label
            if event.id.aspect:
                message += " (%s)" % event.id.aspect
            print(message)
        elif event.kind == "named_set_of_files":
            for file in event.payload.files:
                filepath = file.file.removeprefix("file://")
                if file.name.endswith(".out"):
                    generated = ctx.std.fs.read_to_string(filepath)
                    ctx.std.io.stderr.write(generated)
                if file.name.endswith(".report"):
                    report = ctx.std.fs.read_to_string(filepath)
                    if "sarif-" in report:
                        strategy.process(ctx, state, filepath)
                        continue
                    ctx.std.io.stdout.write(report)
                    if github_output:
                        ctx.std.fs.write(github_output, "lint-report=" + filepath)
                if file.name.endswith(".patch"):
                    patches.append(file.file.removeprefix("file://"))
                if file.name.endswith(".exit_code"):
                    if int(ctx.std.fs.read_to_string(filepath).rstrip()) != 0:
                        exit_code = 1
    state["raw_exit_code"] = exit_code

    # 4. Wait for build
    if not build.wait().success:
        state["build_failed"] = True

    # 5. Apply patches
    if ctx.args.fix:
        for patch in patches:
            ctx.std.process.command("patch").arg("-p1").arg("--input=" + patch) \
                .current_dir(ctx.std.env.current_dir()).spawn().wait()

    # 6. Finish — strategy determines lint exit code
    strategy_exit_code = strategy.finish(ctx, state)

    # Build failure always overrides
    if state.get("build_failed"):
        return 1
    return strategy_exit_code

lint = task(
    implementation = impl,
    config = LintConfig,
    args = {
        "quiet": args.boolean(default = False),
        "fix": args.boolean(),
        "targets": args.positional(minimum = 0),
    },
)
